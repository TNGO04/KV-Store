# Assignment Overview
The purpose of this project is to implement a client, a server, and the communication between them using TCP and UDP protocol. The server acts as a key-value store that stores key-value pairs and allows for operations such as GET (get the value corresponding to a key), PUT (add or update a key-value pair), and DELETE (delete a key and its value from the store). The client gets commands from the command line, sends them over to the server, and then receives a response or acknowledgment from the server. We do not implement the protocol from scratch, but instead, use Java abstractions such as Socket, DatagramSocket, streams, and DatagramPacket to take care of the underlying implementation of network communication. The K-V store is implemented in the Server using a hashmap, and the server takes on the responsibility of creating a socket to listen for commands from the client, parsing the command, executing the command by interacting with the hashmap, and sending a response back to the client. For TCP, the client creates a Socket binds to the ServerSocket, establishes a connection, and an output and input stream to send user commands and receive responses. For UDP, there is no connection to be established, the client simply creates a DatagramSocket and sends a DatagramPacket addressed to the server's host and port. 

# Technical Impression
During this assignment, at first I struggled with how to structure my Client and Server to accommodate both TCP and UDP protocol based on user command. I settle on using a Client and Server class to handle the input parsing and then instantiating the appropriate TCP or UDP instance. I implemented interfaces such as IClient and IServer, which classes like TCPClient, UDPClient, TCPServer, UDPServer can implement to adhere to a consistent interface. The method start() in these interface helps to start the instances of Client and Server, so they can start listening for requests. I also created abstract class AbstractServer to store common code used by both the TCPServer and UDPServer, such as the implementation of the hashmap and command parsing. 

I find the implementation of UDPServer and UDPClient to be harder than the TCP counterpart. For TCP, implementing communication was as easy as setting up ServerSocket and Socket, as well as the input and output streams. For UDP, I needed to set up individual DatagramPacket with each message being sent between server and client, obtain the correct address to add to the packet. In addition, for UDP, I need to set up buffer to obtain the text data from the bytes of packets. I relied on examples from online tutorials and from the article on Canvas to learn more about the Java Object used for implementing these communications. 

For implementing the time-out mechanisms and the logging functionalities, I looked at online documentation for Java and learn to use setSoTimeOut and use Logger objects to log the major events happening on the server and client. In real applications, there can be network problems that prevent a request from being successfully transmitted (especially for UDP), so the timeout mechanism is a must-have for ensuring the client does not hang while waiting for a response. 

One potential application of this project is a client-server simple data storage application. For example, this could be used as a simple way to store people's social security number (SSN) and their name, with the SSN as they key and people's name as the value. For each SSN, there is only one name associated, so a K-V store is perfect for the application. The server can be hosted in a central machine, and multiple client can start TCP or UDP communication with the server using the server's address and port. The multiple client can then be used to look up people's name based on their SSN. This could be a small application in a tax system, with the K-V store in a centralized server, while clients are distributed for different local branches, where auditors can use them to double-check people's name given their SSN. 